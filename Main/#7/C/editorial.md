显然最短的操作序列不包含 $1$，因为 $c_i=1$ 的操作什么用也没有，可以直接删去。

当已经确定操作序列时，去掉操作序列中的重复元素（假设取出后还剩 $m$ 个元素，它们本身构成集合 $S=\{c_i\ |\ i=1,2,\ldots,k\}$，加上元素 $1$ 后构成集合 $T=S\cup\{1\}$），考察 $1$ 号垃圾站和操作序列中涉及到的其他垃圾站：

- 这 $m+1$ 个垃圾站中最开始有 $\displaystyle \sum _{x \in T}a_x$ 袋垃圾。
- 设原操作序列中使得员工们并没有什么都不做的最靠后的出现 $x$ 的位置是 $c_{d_x}=x$，考察 $S$ 中的某个垃圾站 $x$：
   - 如果 $d_x$ 不存在，那么可以直接从原操作序列中删掉所有元素 $x$（以及 $x$ 号垃圾站的所有下级垃圾站、$x$ 号垃圾站的所有下级垃圾站的所有下级垃圾站、……所对应的元素，因为这些垃圾站不可能跨过 $x$ 号垃圾站把垃圾运送到 $1$ 号垃圾站，下同），显然不影响清理垃圾的袋数且可以使得操作序列更短。
   - 同理，如果原操作序列中的某一项使得员工们什么都不做，那么也可以把它删去。
   - 否则，$x$ 号垃圾站中最后：
      - 要么剩下恰好 $d_x$ 袋垃圾。
      - 要么剩下多于 $d_x$ 袋垃圾，但这意味着「它的下级垃圾站后来向它运了垃圾，但这些垃圾最终滞留在了 $x$ 号垃圾站中，没能运到 $1$ 号垃圾站，也没能增加清理垃圾的袋数」，此时显然可以直接选择不进行这些无用的运输，从原操作序列中删掉相关元素。（当然了，在剩下恰好 $d_x$ 袋垃圾的情况中，我们也可以这么做，于是操作序列中在 $c_{d_x}$ 后一定不会再出现任何有关 $x$ 号垃圾站机器下级垃圾站的操作。）

也就是说，设 $S$ 中所有元素 $x$ 对应的 $d_x$ 构成集合 $Q=\{d_i\ |\ i \in S\}$，那么最后留下的垃圾数量要想最少就尽量要让 $Q$ 集合中的所有元素之和 $\displaystyle \sum _{x \in Q} x$ 最小。

然而，在所有 $S$ 集合（或 $T$ 集合）相同的所有操作序列中，既没有相同元素也没有上文提到的这些无用元素的（或者说「最简洁的」）那个操作序列不仅可以实现 $Q=\{1,2,\ldots,m\}$（显然不可能再小了），而且项数显然最少。这样的操作序列一定存在：

- 对于任何一个垃圾站 $x$，考虑删去（如果有）操作序列中除 $c_{d_x}$ 外另一个等于 $x$ 的元素 $c_y=x$：
  - 对于任何一个垃圾站 $z$，只要 $c_{d_z}$ 依然不会使得员工什么都不做（或者说「$c_{d_z}$ 没有失效」），删去 $c_y$ 要么（$d_z<y$ 时，删去 $c_y$ 不影响 $c_{d_z}$ 在操作序列中的位置）不影响 $d_z$，要么（$d_z \ge y$ 时，删去 $c_y$ 使得 $c_{d_z}$ 从操作序列中前移了一位），把 $d_z$ 减小了 $1$：
    - 若 $z$ 没有下级垃圾站，则原来的 $c_{d_z}$ 显然不受对其他垃圾站进行的操作的影响，$c_{d_z}$ 依然不会使得员工什么都不做。
    - 当操作到 $c_{d_z}$ 时，所有应该运给 $z$ 号垃圾站的垃圾已经运送完毕（因为后面不会再运了）。若 $z$ 的下级垃圾站构成的集合 $P_z$ 中的每个下级垃圾站 $f \in P_z$ 都被证明「$c_{d_f}$ 没有失效」，则它们最开始存放了 $\displaystyle \sum _{x \in P_z}a_x$ 袋垃圾，最后滞留了 $\displaystyle \sum _{x \in P_z}d_x$ 袋垃圾，二者之差 $\displaystyle \sum _{x \in P_z}a_x - \displaystyle \sum _{x \in P_z}d_x$ 就是它们运给 $z$ 号垃圾站的垃圾袋数。由上面的分析，$\displaystyle \sum _{x \in P_z}a_x$ 不变，$\displaystyle \sum _{x \in P_z}d_x$ 只会变小或不变，因此二者之差 $\displaystyle \sum _{x \in P_z}a_x - \displaystyle \sum _{x \in P_z}d_x$ 只会变大或不变。由于执行 $c_{d_z}$ 时 $z$ 号垃圾站本就拥有多于 $d_z$ 袋垃圾（$\displaystyle \sum _{x \in P_z}a_x - \displaystyle \sum _{x \in P_z}d_x$ 袋），删除后 $\displaystyle \sum _{x \in P_z}a_x - \displaystyle \sum _{x \in P_z}d_x$ 只会变大或不变，$d_z$ 又只会变小或不变，因此仍然有 $\displaystyle \sum _{x \in P_z}a_x - \displaystyle \sum _{x \in P_z}d_x > d_z$，因此可以断言「$c_{d_z}$ 没有失效」。
    - 综上，对于任何一个垃圾站 $z$，可以断言「$c_{d_z}$ 没有失效」。
  - 删去 $c_y$ 后，考察 $1$ 号垃圾站和操作序列中涉及到的其他垃圾站，它们最开始存放的垃圾袋数之和 $\displaystyle \sum _{x \in T}a_x$ 保持不变（事实上，$a_1,a_2,a_3,\ldots,a_n$ 各自不变）。
  - 综上，删去 $c_y$ 一定是（并非严格地）更优的决策。
- 对于某个垃圾站 $x$，对所有满足上述条件的 $c_y$ 的逐个考虑删去，操作序列中便只会剩下唯一一个（$c_{d_x}$）等于 $x$ 的元素。
- 对 $x=1,2,3,\ldots,n$ 都像上面那样考虑一遍，操作序列中便不会再留下任何两个相同的元素，于是我们成功得到了「最简洁的」操作序列。

因此，我们只需要对每个 $T$ 集合求出一个「最简洁的」操作序列（如果存在的话），然后对这些操作序列进行（清理垃圾袋数和项数的）比较和计数即可。

进一步地，让我们把垃圾站的关系抽象成一棵树，那么 $T$ 集合一定构成一个包含 $1$ 号结点的连通块，于是我们考虑树形 DP，设三元组 $dp_{x,y}$ 表示：

- 只考虑 $T$ 集合在 $x$ 号结点（及其子树）的部分（且这一部分恰好包含 $y$ 个结点）。
- 此时的最多垃圾清理袋数（这里认为运送到 $x$ 号结点就算清理成功）。
- 此时对应的操作序列（这里指完整操作序列的子序列）最小项数。
- 此时最优操作序列的个数。

接下来，我们惊喜地发现：

- 除非不存在「最简洁的」操作序列，否则最优操作序列一定等价于「最简洁的」操作序列。
- 除非不存在「最简洁的」操作序列，否则最优操作序列的操作次数一定是 $y-1$。
- 除非不存在「最简洁的」操作序列，否则最多垃圾清理袋数一定是选定部分的初始垃圾袋数减去 $\displaystyle \sum _{i=1} ^{y-1} i = 1+2+\ldots+(y-1)=\dfrac{y(y-1)}{2}$ 的结果。
- 当不存在「最简洁的」操作序列时，如果将目前的最优操作序列中的无用操作去掉，得到一个「最简洁的」操作序列，那么这个操作序列：
    - 项数一定少于目前的最优操作序列。
    - 垃圾清理袋数一定不少于目前的最优操作序列。
    - 所对应的「$T$ 集合在 $x$ 号结点（及其子树）的部分」的结点数一定不大于（实际上是严格小于，因为我们已经假设了「不存在「最简洁的」操作序列」）目前的最优操作序列。
    - 一定在某个 $dp_{x,z}$ 中（$z<y$）被统计过了，于是从 $dp_{x,y}$ 向上转移出来的答案都不是最优解（都比从 $dp_{x,z}$ 向上转移出来的答案更劣），我们不会在最终的答案计算中采纳任何涉及 $dp_{x,y}$ 的答案。
- 当不存在「最简洁的」操作序列时，我们会把（本就不是全局最优解的）目前的最优操作序列的垃圾清理袋数算少（因为无用操作的本质是剩余垃圾太少运不上去，如果无用操作对应的那些垃圾站最终剩下的垃圾袋数的总和多于对应的 $d$ 序列中的预测值的总和，那么由前面的分析可知我们一定可以多运一些垃圾上去，这与它们是无用操作的试试矛盾，于是我们只会把最终剩下的垃圾袋数算多，而不会算少，这导致我们把目前的最优操作序列的垃圾清理袋数算少），于是我们更不会在最终的答案计算中采纳任何涉及 $dp_{x,y}$ 的答案。

也就是说，根据树形 DP 的流程，我们可以放心大胆地假设「最简洁的」操作序列有一定存在，因为我们不会在最终的答案计算中采纳任何涉及并非「最简洁的」操作序列的答案。

最后，当两个方案数分别为 $w_1,w_2$，项数分别为 $l_1,l_2$ 的子序列合并时，大序列的方案数为 $\displaystyle w_1w_2\binom{l_1+l_2}{l_1}=w_1w_2C_{l_1+l_2}^{l_1}=w_1 \cdot w_2 \cdot \dfrac{(l_1+l_2)!}{l_1! \cdot l_2!}$，其中组合数可以 $O(n^2)$ 预处理。

最终的时间复杂度为 $O(Tn^2)$，空间复杂度为 $O(n^2)$。

std 的 DP 实现与上文中的 DP 策略有两点不同：

- std 中 $y$ 指操作序列长度，比上文中的 $y$ 少 $1$。
- std 在 DP 过程中没有扣掉剩余的垃圾袋数，因此计算最终答案时需要在 std 中减去 $\dfrac{y(y+1)}{2}$。
